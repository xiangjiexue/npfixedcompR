% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/npfixedcompR.R
\name{gradientfunction}
\alias{gradientfunction}
\title{The gradient function}
\usage{
gradientfunction(x, mu, mu0, pi0, order)
}
\arguments{
\item{x}{a object from implemented family}

\item{mu}{a vector of locations to look for}

\item{mu0}{a vector of support points}

\item{pi0}{a vector of weights corresponding to the support points}

\item{order}{a vector of length 3 with either 1 or 0. 1 to compute, 0 not to compute.}
}
\value{
a list of length 3. d0, d1, d2 correspond to the order.
}
\description{
This is a S3 generic function for computing the gradient function and/or its derivatives
}
\details{
The computation of the gradient function and/or its derivative is computed by specification
of order. For example, \code{order = c(0, 1, 1)} computes the first and second derivative of
the gradident function but not the function itself. At least \code{order = c(1, 0, 0)} must
be implemented.

When finding the new support points, the function \code{solvegradientmultiple} can choose
the algorithms automatically by specifying \code{method = "auto"} and the algorithm is chosen
based on the minimal working output in the family. Alternatively, if a user know which algorithm
is most efficient, the specification of algorithm can be made by \code{method = "d0"}
(derivative-free minimisation), \code{method = "d1"} (derivative-free root finding) and
\code{method = "d1"} (root-finding using first derivative.).

The full list of implemented family is in \code{\link{makeobject}}.
}
